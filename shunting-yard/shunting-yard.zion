import vector {shrink_to}
import sys {args}

data Expr {
  ETerm(String)
  EOp(String, Expr, Expr)
  EPrefix(String, Expr)
  EPostfix(String, Expr)
}

instance Str Expr {
  fn str(a) => match a {
    ETerm(s) => s
    EOp(op, lhs, rhs) => "(${lhs} ${op} ${rhs})"
    EPrefix(op, rhs) => "${op}${rhs}"
    EPostfix(op, rhs) => "${rhs}${op}"
  }
}

fn push(xs, x) => xs.append(x)
fn peek(xs) => len(xs) != 0 ? Just(xs[len(xs)-1]) : Nothing
fn pop(xs) => match peek(xs) {
   jx@Just(_) {
    xs.shrink_to(len(xs)-1)
    jx
  }
  Nothing => Nothing
}

data Assoc {
  ALeft
  ARight
}

instance Eq Assoc {
  fn ==(a, b) => match (a, b) {
    (ALeft, ALeft) => True
    (ARight, ARight) => True
    _ => False
  }
}

newtype Rule = Rule(Int, Assoc, [Fixity])
data Fixity {
  Infix
  Prefix
  Postfix
}

let known_operators = {
  "+": Rule(1, ALeft, [Infix]),
  "-": Rule(1, ALeft, [Infix, Prefix]),
  "*": Rule(2, ALeft, [Infix]),
  "/": Rule(2, ALeft, [Infix]),
  "^": Rule(3, ARight, [Infix]),
  "++": Rule(3, ARight, [Postfix, Prefix]),
}
let parentheses = ["(", ")"]

fn is_operand(term) {
  return term not in known_operators and term not in parentheses
}

fn rule(op) {
  if known_operators[op] is Just(rule) {
    return rule
  } else {
    assert(False)
    return Rule(0, ALeft, [])
  }
}

data Op {
  Op(String, Int)
  NoOp
}

fn apply(operands, operator) {
  assert(len(operands) >= 2)
  if operands.pop is Just(rhs) {
    if operands.pop is Just(lhs) {
      operands.push(EOp(operator, lhs, rhs))
      return
    }
  }
  print("failed to apply ${operator} to ${operands}")
}

data Token {
  Operator
  Operand
}

instance Eq Token {
  fn ==(a, b) => match (a, b) {
    (Operator, Operator) => True
    (Operand, Operand) => True
    _ => False
  }
}

fn main() {
  if len(args) != 2 {
    print("give a quoted expression with {${" ".join(known_operators.keys)}}.\nnote that all terms and operators must be separated by a space.\nlike: \"a + b ^ c ^ d - ( e - f - g ) ^ 42\"")
    return
  }
  let terms = [term.strip for term in args[1].split(" ") if term.strip.len > 0]
  let operands = new [Expr]
  let operators = new [Op]
  var last_token = Operator
  var last_term = ""
  for term in (t.strip for t in terms) {
    if term.is_operand {
      if last_token == Operand {
        print("juxtaposition is not-impl [${last_term}, ${term}]")
        return
      }
      last_token = Operand
      operands.push(ETerm(term))
    } else if term == "(" {
      last_token = Operator
      operators.push(Op(term, -1))
    } else if term == ")" {
      last_token = Operand
      while operators.pop is Just(Op(top_operator, _)) {
        if top_operator == "(" {
          break
        } else {
          operands.apply(top_operator)
        }
      }
    } else {
      let Rule(cur_precedence, cur_assoc, cur_fixities) = term.rule
      while operators.peek is Just(Op(top_operator, top_precedence)) {
        if top_operator != "(" and (
          top_precedence > cur_precedence or (top_precedence == cur_precedence and cur_assoc == ALeft)) {
          operands.apply(top_operator)
          operators.pop!
        } else {
          break
        }
      }
      operators.push(Op(term, cur_precedence))
      last_token = Operator
    }
    last_term = term
  }
  while operators.peek is Just(Op(operator, _)) {
    operands.apply(operator)
    operators.pop!
  }
  print(operands)
}
